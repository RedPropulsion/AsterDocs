{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Red Propulsion Documentation","text":"<p>Qua ci sar\u00e0 il logo</p> <p>Welcome to the official documentation for Red Propulsion projects. This guide provides comprehensive information about the hardware and software systems developed by the team.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":""},{"location":"#1-home","title":"1. Home","text":"<ul> <li>Overview of the documentation repository.</li> </ul>"},{"location":"#2-api-reference","title":"2. API Reference","text":"<ul> <li>Detailed API documentation for the AsterCPP project.</li> </ul>"},{"location":"#3-hardware","title":"3. Hardware","text":"<p>Asterics:</p> <ul> <li>PWR: Power systems documentation.</li> <li>MCU: Microcontroller details.</li> <li>SENSR: Sensor specifications.</li> <li>TELEM: Telemetry systems.</li> </ul> <p>Obelics:</p> <ul> <li>Overview: General information about Obelics.</li> <li>Funzioni disponibili: Available functions.</li> </ul>"},{"location":"#4-controls","title":"4. Controls","text":"<p>da fare</p>"},{"location":"#5-runner","title":"5. Runner","text":"<ul> <li>Overview: Introduction to the runner system.</li> <li>DocsRunner: Configuration and workflow details for documentation runners.</li> </ul>"},{"location":"#6-guide-varie","title":"6. Guide varie","text":"<ul> <li>How to edit documentation: quick start on how to edit the documentation.</li> <li>Guidelines: rules to follow to mantain consistent documentation standards.</li> <li>Build the project: instructions to build the project outside the STM32 IDE.</li> <li>Debug the project: instructions to debug the project with CLion.</li> </ul>"},{"location":"#markdown-extensions-for-commenting","title":"Markdown Extensions for Commenting","text":"<p>To facilitate collaboration and commenting on both hardware and software topics, the following markdown extensions are supported:</p> <ul> <li> <p>Admonitions: Use callouts for notes, warnings, and tips.</p> <pre><code>!!! note\n    This is a note.\n</code></pre> <p>Warning</p> <p>This is a waring</p> </li> </ul>"},{"location":"guide/build-the-project/","title":"Build RedAster outside STM32CubeIDE","text":"<p>Follow the next steps to build the project with CMake on any platform.</p>"},{"location":"guide/build-the-project/#requirements","title":"Requirements:","text":"<ul> <li>CMake Version:    The project requires the 3.28 minimum version for CMake, so make sure to have the right version installed. To check  the version:    <pre><code>cmake --version\n</code></pre></li> <li>Arm GNU Toolchain:   To build an embedded project base on Amr Cortex is required to have the right compiler toolchain.   Download it from Arm's official website for your OS.   Or get it with a package manager.</li> </ul> <p>macOS:   <pre><code>brew install arm-none-eabi-gcc\n</code></pre>   Linux:   <pre><code>sudo apt install gcc-arm-none-eabi\n</code></pre>   Windows:   <pre><code>choco install gcc-arm-embedded\n</code></pre></p>"},{"location":"guide/build-the-project/#build-the-project","title":"Build the project:","text":"<p>At this point you have the needed tools. Run the following bash commands to create a folder called build to store all  the files generated by CMake, including the .bin and .elf files. The -S flag is needed to provide the directory that  contains the source files (\" . \" means the directory you are located right now), and -B flag specifies the build directory  (if it does not exist CMake will create it for you). Then you run the command that actually builds the program.</p> <pre><code>cmake -S . -B build # use the current directory as source dir and create build \ncmake --build build # compiles the project in the build folder\n</code></pre>"},{"location":"guide/debug-the-project/","title":"Debug RedAster in CLion","text":"<p>Follow the next steps to debug the project with CLion.</p>"},{"location":"guide/debug-the-project/#requirements","title":"Requirements:","text":"<ul> <li>Open OCD:   First of all you have to have installed Open OCD (Open On-Chip Debugger), an open-source utility to debug microcontrollers.   It can be installed through a package manager:</li> </ul> <p>macOS:    <pre><code>brew install open-ocd\n</code></pre>   Linux:    <pre><code>sudo apt-get install openocd\n</code></pre>   Windows:    <pre><code>choco install openocd\n</code></pre> * GDB:   Make sure to have installed GDB (GNU Debugger). It can be installed through a package manager:</p> <p>macOS:    <pre><code>brew install gdb\n</code></pre>   Linux:    <pre><code>sudo apt-get install gdb\n</code></pre>   Windows:   Follow the instructions on this page: MinGW System.</p>"},{"location":"guide/debug-the-project/#create-the-clion-configuration","title":"Create the CLion Configuration:","text":"<p>Follow the next steps to debug your code inside CLion:</p> <ol> <li>Go in the settings and set the Embedded Development specifications.</li> <li>Create a new configuration for your build. Make sure is an \"OpenOCD Download &amp; Run\" type of configuration.</li> </ol> <p> </p> <ol> <li>Now fill the settings with as \"Target and Executable binary\" the RedAster.elf . Then as \"Board config file\" specify    the path of the \"custom_st_nucleo_h723ZG.cfg\" present in the repo.</li> </ol> <p> </p>"},{"location":"guide/edit-docs/","title":"Come usare la documentazione","text":"<p>Tutorial on how to edit, name and organize pages in this documentation repository to share knowledge and ensure clear communication and informations on subsystem functionality.</p>"},{"location":"guide/edit-docs/#editing-documents","title":"Editing documents","text":"<ol> <li>Locate the file    The documentation root is the <code>docs/</code> directory</li> <li><code>index.md</code> is the main homepage. It's the page you see rendered on <code>docs.redpropulsion.it</code></li> <li> <p>The folder structure reflects the pages in the website</p> <ul> <li>e.g. <code>hw/asterics/pwr.md</code> it's equivalent to navigate to <code>docs.redpropulsion.it/hw/asterics/pwr</code></li> </ul> </li> <li> <p>Edit the content    Open the file in your favourite text editor and apply the changes you need. Use markdown syntax for formatting. We are using mkdocs-material as the theme engine for the docs, it adds many features over the plain mkdocs, so please refer to its docs to better use it</p> </li> <li> <p>Preview changes    You can preview the changes to the documentation by serving the webserver locally by doing <code>mkdocs serve</code> and then going to the local webserver hosted (typically) on port <code>8000</code></p> </li> </ol>"},{"location":"guide/edit-docs/#adding-new-documents","title":"Adding new documents","text":"<ol> <li>Create the file (with <code>.md</code> format) in the appropiate directory and with a descriptive name.</li> <li>Save, e.g. we just created a new doc called <code>new-board.md</code> in the <code>docs/hw/</code> folder.</li> <li>Update the navigation configuration    open the <code>mkdocs.yml</code> and go in the <code>nav</code> section.</li> </ol> <pre><code>nav:\n - Hardware:\n     - Overview: hw/index.md\n     - Nuova scheda: hw/new-board.md\n</code></pre> <ol> <li>If the documentation needs it, you may also have to update (or add) the references to that page in the index or parent page to be able to reach it more efficiently</li> </ol>"},{"location":"guide/edit-docs/#adding-media","title":"Adding media","text":"<p>To add media use the <code>assets</code> folder to upload images and reference them in your code.</p>"},{"location":"guide/edit-docs/#naming-convention","title":"Naming Convention","text":"<p>Note</p> <p>TODO: do be determined</p> <ul> <li> <p>File names:   all lowercase letters and spaces must be repplaced with dashes <code>-</code></p> </li> <li> <p>Headings:   This follows the markdown specs: only one header per page as the main title (<code>#</code>) and <code>##</code> or <code>###</code> for subsections.</p> </li> </ul>"},{"location":"guide/edit-docs/#markdown-features-and-extensions","title":"Markdown Features and Extensions","text":"<p>This repository supports advanced Markdown features. Use the following extensions for better formatting:</p> <ol> <li> <p>Admonitions:    Add notes, warnings, or tips:    <pre><code>!!! note\n    This is a note.\n!!! warning\n    This is a warning.\n</code></pre></p> </li> <li> <p>Collapsible Sections:    Use collapsible sections for detailed content:    <pre><code>??? info \"Click to expand\"\n    Detailed information goes here.\n</code></pre></p> </li> <li> <p>Mermaid Diagrams:    Add diagrams for workflows or architecture:    <pre><code>graph TD;\n    A--&gt;B;\n    B--&gt;C;\n</code></pre></p> </li> <li> <p>Tabbed Content:    Use tabs for alternative views:    <pre><code>=== \"Option 1\"\n    Content for option 1.\n=== \"Option 2\"\n    Content for option 2.\n</code></pre></p> </li> </ol>"},{"location":"guide/edit-docs/#publishing-changes","title":"Publishing changes","text":"<p>Create a commit with an appropiate title to describe what you edited/added/deleted and push it to remote. The runner will take care of the rest and automagically publish the changes in a few seconds.</p>"},{"location":"hw/","title":"home hardware","text":""},{"location":"hw/#le-schede","title":"Le Schede:","text":"<ul> <li>MCU</li> <li>PWR</li> <li>SENS</li> <li>TELEM</li> <li>RING</li> </ul>"},{"location":"hw/#tutorial","title":"Tutorial:","text":"<p>NEOPIXEL \\ TIMER</p>"},{"location":"hw/asterics/mcu/","title":"Asterics MCU board","text":"<p>prova</p>"},{"location":"hw/asterics/ring/","title":"RING","text":"<p>LED, sensori di temperatura, SICURA, alimentazione</p>"},{"location":"hw/peripheral/addressable-led/","title":"Addressable led(s)","text":""},{"location":"hw/peripheral/addressable-led/#documentazione-da-pdf","title":"Documentazione da PDF:","text":"<p>Abbiamo a disposizione 13 LED disposti lungo l'esterno del pcb di asterics-MCU. Sono controllati attravero il pin PB9 del microcontrollore. Hanno a disposizione il timer 17 e il timer 4 per il pilotaggio. Abbiamo inoltre a disposizione una striscia LED lungo il diametro della fusoliera. Questi sono controllati attraverso il PB8.</p> <p>Per risparmiare energia quando i led sono spenti, sulla MCU \u00e8 presente un mosfet per abilitare la rail di alimentazione PF6, mentre nel RING l'alimentazione viene abilitata da un regolatore su PWR attraverso il pin PF5.</p>"},{"location":"hw/peripheral/addressable-led/#come-controllare-i-neopixel","title":"Come controllare i neopixel?","text":"<p>Questa tipologia di led indirizzabile sfrutta un protocollo \"proprietario\" che codifica gli stati logici di <code>1</code> e <code>0</code> modulando l'ampiezza di un'onda quadra, cio\u00e8 con un PWM. Per questo motivo possiamo utilizzare la funzione dei timer dell'stm per generare gli impulsi di periodo e ampiezza appropiati. I led comunicano ad una velocit\u00e0 fissata di \\(800\\text{kHz}\\), questo vuol dire che ogni bit viene trasmesso ogni \\(1.25\\mu s\\).</p>"},{"location":"hw/peripheral/addressable-led/#fisicamente-cosa-accade","title":"Fisicamente cosa accade?","text":"<p>I neopixel che abbiamo montato sono pensati per lavorare a 5V, ma possono tranquillamente lavorare con un'alimentazione a 3.3V, nel nostro caso gli forniamo 5V direttamente dal rail principale. Logicamente li facciamo lavorare con un segnale a 3.3V. Come si nota dalla figura presa dallo schema elettrico, i singoli PIXEL, ovvero i led fisicamente montati sul PCB, sono collegati a cascata: l'uscita del primo \u00e8 connessa con l'ingresso del secondo e cos\u00ec via. Internamente ciascun pixel, \u00e8 composto da 3 led: uno per ogni componente Rosso, Verde, Blu. </p> <p>Ciascun LED (ovvero uno dei 3 di ogni pixel) ha una risoluzione di 8bit. Questo vuol dire che per indicare il colore di un pixel avremo bisogno di 24bit che dovranno essere inviati uno di seguito all'altro con l'ordine dato dalla documentazione dei led: . Per impostare il colore sul secondo pixel della serie si continua a trasmettere. Nella logica interna del pixel vengono utilizzati i primi 24bit che riceve (e non li ritrasmette in uscita) mentre dal 25-esimo in poi vengono riamplificati e mandati al pixel successivo.</p> <p>Avendo a disposizione 13 pixel, ognuno dei quali ha bisogno di 3 byte per indicare il colore, per immagazzinare l'informazione di ciascun pixel avremo bisogno di \\(13\\times 3=39\\text {byte}\\) + 50byte in coda tutti da 0 per indicare che intendiamo resettare la comunicazione e ripartire dal pixel 0. Per semplicit\u00e0 supponiamo di dover allocare un buffer da 100byte.</p>"},{"location":"hw/peripheral/addressable-led/#come-utilizzare-il-timer-e-il-dma-per-inviare","title":"Come utilizzare il timer (e il DMA) per inviare","text":"<p>Info</p> <p>(tralasciamo inizialmente i discorsi operativi su come impostare la temporizzazione)</p> <p>Abbiamo detto che i pixel comunicano con il duty cycle di un segnale pwm. Sappiamo che il periodo di questo segnale deve essere \\(1.25\\mu s\\). Abilitiamo il timer corretto per i pin che vogliamo usare, abilitiamo la funzione \"pwm generation chx\". Nel men\u00f9 dei parametri impostiamo l'ARR (Auto Reload Register) in modo che la frequenza di lavoro sia \\(800 kHz\\), mi segno anche questo valore perch\u00e8 sar\u00e0 utile tra poco.</p> <p>Adesso vado nella sezione DMA e abilito una richiesta per l'aggiornamento del DMA al canale appena abilitato. La direzione deve essere da memoria a periferica e la priorit\u00e0 \u00e8 da vedere.  Un'altro parametro da considerare \u00e8 il \"mode\" ovvero se considerare il buffer dei pixel come circolare o normale. La differenza dovrebbe essere che nel caso del buffer circolare il dma non si ferma automaticamente (ma non prendete queste parole per vero, se lo testate correggetemi grazie). Impostare anche l'incremento di indirizzo nella memoria. La larghezza delle parole non \u00e8 importante.</p> <p>Riassuntino</p> <ul> <li>Chiamiamo tutti i dispositivi connessi pixel, ciascun pixel \u00e8 composto da 3 led.</li> <li>Per indicare il colore da mostrare su ciascun pixel abbiamo bisogno di 24 bit: 3 parole da 1 byte ordinate GRB con primo bit MSB</li> <li>Per inviare ciascun bit utilizziamo un segnale PWM con dyty cycle specifico.</li> <li>Dobbiamo inviare di seguito ciascun bit, se non inviamo alcun dato e lasciamo il \"filo\" basso per \\(t&gt;280\\mu s\\) la comunicazione si resetta e possiamo reimpostare il primo pixel.</li> <li>I pixel lavorano come degli shift register, ma al contrario: i primi 24 bit vanno al primo pixel, dal 25esimo al 49esimo al secondo e cos\u00ec via.</li> <li>Per generare il segnale PWM a duty cycle utilizziamo una periferica timer del microcontrollore in combinazione al DMA per alleggerire il carico sulla logica di controllo</li> </ul> <p>Per semplificare la comunicazione con i led, possiamo utilizzare il DMA: configuriamo la periferica timer in modo che utilizzi un canale del dma in modo che ogni volta che ha finito di trasmettere il singolo bit, il dma aggiorni il valore del registro pulse con il valore successivo. \\ Per fare questo abbiamo bisogno di 2 cose: 1. un buffer abbastanza capiente per le informazioni dei led    !!! note    \u00e8 possibile anche usare un mezzo buffer e usare il callback corrispondente per risparmiare memoria</p> <ol> <li>implementare da qualche parte il Callback del TIM PWM PulseFinishedCallback</li> <li>Implementare un metodo che faccia partire lo stream del DMA per il timer e il canale corretto</li> </ol> <p>A questo punto possiamo implementare le funzioni che aggiornano/impostano i colori dei led a seconda dell'operazione da effettuare.</p>"},{"location":"hw/peripheral/addressable-led/#come-configurare-il-timer","title":"Come configurare il timer","text":"<p>Per la teoria generale su come funzioni / cosa sia / cosa faccia il timer guarda la sua pagina di documentazione qua.</p> <p>Dando per scontato il funzionamento di base, dobbiamo impostare il periodo di ripetizione del timer tale da generare un segnale a \\(800\\text{kHz}\\), che da adesso chiameremo \\(f_{PWM}\\) quindi avremo bisogno di sapere la frequenza di lavoro del timer in questione (aprendo il datasheet e navigando al block diagram del microcontrollore o aprendo questo file qua).</p> <p>Troviamo quindi a quale dominio il nostro timer appartiene, ad esempio APB2. Adesso andiamo nella \"clock configuration\" dell'ioc e cerchiamo a quale frequenza lavora il corrispondente dominio.</p> <p>Warning</p> <p>Questa sar\u00e0 la frequenza in ingresso al timer \\(f_{tim}\\)</p>"},{"location":"hw/peripheral/addressable-led/#calcolo-dellarr","title":"Calcolo dell'ARR","text":"<p>Dobbiamo configurare il timer in modo da ottenere la \\(f_{PWM}\\) corretta. Per farlo dobbiamo trovare il valore del registro \\(ARR\\) che consente questa divisione. Per trovarlo faremo quindi:</p> <p>\\(\\(ARR = \\frac{f_{tim}}{f_{PWM}} - 1\\)\\) Possiamo inserire solo numeri interi, quindi nel caso in cui non venga un rapporto intero si pu\u00f2 approssimare.</p>"},{"location":"hw/peripheral/addressable-led/#calcolo-dutycycle-bit","title":"Calcolo DutyCycle bit","text":"<p>Non resta che calcolare quanto deve valere il duty cycle per indicare il valore 0 e 1. Per farlo dobbiamo capire l'intervallo di tempo che il segnale generato dal timer rimanga alto e quanto basso. </p> <p>Warning</p> <p>Questo parametro specialmente \u00e8 dipendente dal tipo di neopixel usato, quindi \u00e8 sempre meglio controllare sul datasheet</p> <p>Nel caso dei WS2812B-4020, abbiamo da rispettare questa chiarissima temporizzazione che si traduce nel fatto che per indicare uno \\(ZERO\\) dobbiamo tenere il segnale alto per \\(1/4\\) del periodo, mentre per indicare un \\(UNO\\) dobbiamo stare intorno ai \\(3/4\\) del periodo. Sperimentalmente si pu\u00f2 provare diversi valori e spesso vale anche che lo \\(ZERO\\) si ha quando il segnale \u00e8 alto per \\(1/3\\) e l'\\(UNO\\) quando \u00e8 alto per \\(2/3\\) </p> <p>In ogni caso, dobbiamo capire come indicare al timer come impostare queste frazioni del periodo, per farlo dobbiamo impostare il valore nel registro pulse, o meglio, dovremmo farlo in quanto di questa operazione se ne occuper\u00e0 il DMA e un nostro metodo incaricato di convertire la parola da 8bit in 8 parole da 16bit per il buffer da mandare al DMA.</p> <p>Quindi: \\(\\(\\begin{align}ZERO = (ARR+1) \\cdot 1/4 \\\\ UNO = (ARR+1) \\cdot 3/4\\end{align}\\)\\)</p> <p>Anche in questo caso \u00e8 probabile che non si ottengano dei valori interi, per fortuna i neopixel non sono cos\u00ec fiscali con le temporizzazioni e quindi \u00e8 possibile arrotondare all'intero pi\u00f9 vicino senza che i simboli vengano fraintesi.</p>"},{"location":"hw/peripheral/addressable-led/#implementazione-codice","title":"Implementazione Codice","text":"<p>TODO: spiegone</p>"},{"location":"hw/peripheral/addressable-led/#ws2812b","title":"WS2812b","text":"<p>Sulla scheda abbiamo a disposizione 12 led rgb disposti a cerchio sul diametro esterno. Se la scheda viene operata senza la rossa, allora i led a disposizione sono solo 2. Pertanto le notifiche pi\u00f9 vitali sono riportate sui primi 2 led.</p> <p>A seconda del pattern di lampeggio e dei colori abbiamo messaggi diversi:</p> <ul> <li>Tutti i led sfumano dal rosso allo spento ogni secondo -&gt; Procedura di cancellazione della flash in corso</li> <li>Rapido lampaggio on off rosso -&gt;    TODO: tabella con spiegazione degli errori</li> </ul>"},{"location":"hw/peripheral/addressable-led/#teoria-sui-led-indirizzabili","title":"Teoria sui led indirizzabili","text":"<p>Prendono in ingresso un segnale pwm che rappresenta l'<code>1</code> o lo <code>0</code> logico a seconda della lunghezza della durata della parte alta del segnale. Il periodo del segnale PWM deve essere di \\(1.25 \\mu s\\).</p> <p>Per i led che usiamo noi abbiamo che lo <code>0</code> logico corrisponde ad un \"on time\" di \\(0,4\\mu s\\). Mentre l'<code>1</code> vuole un \"on time\" di \\(0,8\\mu s\\).</p>"},{"location":"hw/peripheral/addressable-led/#come-configurare-il-progetto-per-avere-i-led-funzionanti","title":"Come configurare il progetto per avere i led funzionanti:","text":"<p>Si pu\u00f2 usare sia il timer 8 che il timer 3. In entrambi i casi il canale \u00e8 l'1</p>"},{"location":"hw/peripheral/addressable-led/#impostare-il-timer","title":"Impostare il timer","text":"<p>Supponendo di aver settato il clock ad una frequenza di \\(f_{clk}=100Mhz\\). Dobbiamo andare a impostare l'AutoReloadRegister (ARR) in modo da ottenere il periodo da noi desiderato, quindi diremo che \\(\\(ARR - 1 = \\frac{f_{clk}}{f_{led}} = \\frac{100MHz}{(1,25 \\mu s)^{-1}} = \\frac{100MHz}{800kHz} = 125 -1\\)\\) (nota che il -1 \u00e8 dovuto al fatto che nell'ioc devi mettere 124)</p> <p>A questo punto non resta che controllare che il registro \"pulse\" del canale corretto sia uguale a 0.</p> <p>Ricorda di abilitare lo stream DMA in memory to peripheral</p>"},{"location":"hw/peripheral/addressable-led/#assegnare-i-valori-corretti-ai-bit","title":"Assegnare i valori corretti ai bit","text":"<p>Come detto prima lo 0 e l'1 logici corrispondono a dei duty cycle. Calcoliamoli: lo <code>0</code> corrisponde ad un duty cycle di \\(1/3\\), quindi \\(\\frac{125}{3} \\approx 42\\). Mentre l'<code>1</code> corrisponde a \\(84\\). Questi valori vanno impostati per la funzione che converte il valore da uint8 a valori del pwm da mettere nell'array che viene dato in pasto al DMA </p>"},{"location":"hw/peripheral/timer/","title":"Mega tutorial Timer","text":"<p>TODO: aggiungere backlink a tutte le pagine che lo nominano</p>"},{"location":"runner/","title":"ciao","text":"<p>Per sapere come funziona il runner vai qua</p>"},{"location":"runner/config_runner/","title":"Spiegazione della configuazione utilizzata nei runner","text":"<p>Il processo di build della documentazione funziona in due step: quando viene fatta una modifica su AsterCPP o una PR, parte in automatico il processo che controlla che le modifiche apportate facciano buildare correttamente. Viene inoltre generata la documentazione con doxygen, viene trasformata con mkdoxy e pushata qua in AsterDocs per essere integrata con la documentazione generale.</p> <p>Pushando la documentazione qua parte la fase 2, che compila la documentazione presente su AsterDocs e la pusha su gh pages automaticamente.</p> <pre><code>---\nconfig:\n  theme: mc\n  look: classic\n---\nflowchart TD\n subgraph s1[\"AsterCPP build runner\"]\n        n6[\"cmake build\"]\n        n7[\"Doxygen documentation \"]\n  end\n    n3[\"Modifica su AsterCPP\"] --&gt; n7 &amp; n6\n    n7 --&gt; n11[\"check \"]\n    n6 --&gt; n9[\"Build successful?\"]\n    n9 -- No --&gt; n10([\"Modifica bloccata \"])\n    n9 -- Si --&gt; n11\n    n11 --&gt; n8[\"Push to AsterDocs \"]\n    n6@{ shape: lin-proc}\n    n7@{ shape: lin-proc}\n    n3@{ shape: rounded}\n    n11@{ shape: tri}\n    n9@{ shape: diam}\n     n10:::Rose\n     n10:::Class_01\n    classDef Rose stroke-width:1px, stroke-dasharray:none, stroke:#FF5978, fill:#FFDFE5, color:#8E2236\n    classDef Class_01 fill:#FFCDD2, stroke:#D50000, stroke-width:1px, stroke-dasharray: 0, color:#000000\n    style n10 fill:transparent,color:none\n    linkStyle 4 stroke:#D50000,fill:none\n    linkStyle 5 stroke:#00C853\n</code></pre> <pre><code>---\nconfig:\n  theme: mc\n  look: classic\n---\nflowchart LR\n subgraph s1[\"AsterDocs documentation runner\"]\n        n6[\"mkbook \"]\n        n7[\"mkdoxy \"]\n  end\n    n7 --&gt; n6\n    n3[\"Push su AsterDocs \"] --&gt; s1\n    s1 --&gt; n8([\"Github Pages\"])\n    n6@{ shape: lin-proc}\n    n7@{ shape: lin-proc}\n    n3@{ shape: rounded}\n    classDef Rose stroke-width:1px, stroke-dasharray:none, stroke:#FF5978, fill:#FFDFE5, color:#8E2236\n    classDef Class_01 fill:#FFCDD2, stroke:#D50000, stroke-width:1px, stroke-dasharray: 0, color:#000000\n\n</code></pre>"},{"location":"AsterCPP/annotated/","title":"Class List","text":"<p>No classes, structs, unions or interfaces found.</p>"},{"location":"AsterCPP/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p>"},{"location":"AsterCPP/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"AsterCPP/classes/","title":"Class Index","text":""},{"location":"AsterCPP/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"AsterCPP/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"AsterCPP/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"AsterCPP/class_members/","title":"Class Members","text":"<p>Nothing related to Class Members found.</p>"},{"location":"AsterCPP/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"AsterCPP/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"AsterCPP/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"AsterCPP/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"AsterCPP/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"AsterCPP/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"AsterCPP/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"AsterCPP/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"AsterCPP/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"AsterCPP/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"AsterCPP/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"AsterCPP/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"AsterCPP/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}